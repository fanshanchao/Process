# Leetcode-Stack

> 各个数据结构和算法之前都要明白一点，每种数据结构和算法都有它的优点和缺点， 没有最好，只有最适合的。
>
> 总结基于已经刷过的Leetcode栈标签的题目。

栈是一个先进后出的数据结构，它只能在栈尾进行入栈和出栈操作。下图就是栈的入栈和出栈操作。

![image-20201226162837633](https://fanshanchao.oss-cn-shenzhen.aliyuncs.com/img/image-20201226162837633.png)

## 函数的调用

栈的先进后出特点非常适合我们程序中的函数调用，最先调用的函数会第一个入栈，然后第二个调用的继续入栈....最后一个被调用的函数会从栈顶出栈，然后再继续处理栈顶的函数，这样就形成了一个函数的调用过程。下面是一个很简单的代码实例和利用栈来实现函数调用的示意图：

```java
public class StackExample {
    public static void main(String[] args) {
        process1();
        System.out.println("end.....");
    }
    private static void process1(){
        process2();
    }
    private static void process2(){

    }
}
```

![image-20201226165637519](https://fanshanchao.oss-cn-shenzhen.aliyuncs.com/img/image-20201226165637519.png)

* [Leetcode-636-函数独占的时间](https://leetcode-cn.com/problems/exclusive-time-of-functions/)

  这个题的思路是，遇到start日志，就把对应的函数id入栈。在遇到一条包含end的函数时，我们将对应的函数id出栈。在每一个时刻，栈中的所有函数均为被调用的函数，而栈顶的函数为正在执行的函数。栈的情况和上面这个图有点类似。核心思路如下：

  1. 遍历日志数组中的每条日志
  2. 如果是start日志则入栈，否则出栈，计算栈顶日志和当前日志的时间差，利用这个时间差计算每个函数的独占时间。

## 字符串匹配

栈先进先出的特点非常适合一类问题的解决：字符串的匹配。

* [Leetcode-20-有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)

  这个题目是验证一个包含括号的字符串是否有效。一个有效的括号字符串，从左到右数，第一个右括号一定是和最后一个左括号进行匹配的，第二个右括号是和倒数第二个左括号进行匹配.....而这个匹配过程就可以用栈来实现。用栈的实现的核心思路如下：

  1. 遍历每个字符，对每个字符做如下操作。

  2. 如果是左括号，那么就入栈。

  3. 如果是右括号，则说明栈顶必须有一个左括号与之匹配，如果匹配上了，那就将栈顶的左括号出栈，继续处理字符串中的下一个字符，如果没有匹配上，那说明这个字符串不是有效的。
  4. 遍历结束，如果这个栈不为空，这个字符串也不是有效的。

* [Leetcode-71-简化路径](https://leetcode-cn.com/problems/simplify-path/)

  这个题关键在于简化**..**这个路径，遇到**..**需要返回到上一级路径，而路径一层层的深入其实就像我们的入栈操作，返回上一级其实就是将栈顶元素出栈，所以这个题用栈的思路如下：

  1. 先按/分割路径
  2. 遍历字符串数组
  3. 如果是..则将栈顶元素出栈，如果不是.且不是空字符则入栈
  4. 最后形成的栈内元素便是最终的结果
  
* [Leetcode-150-逆波兰表达式求值](https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/)

  很经典的**栈运用**的题目，直接说核心思路：

  1. 遍历字符串的每个字符
  2. 如果当前字符是数字，那么直接入栈
  3. 如果当前字符是运算符，则从栈中出栈两个数字，对两个数字做相应运算，并将结果入栈，继续2。
  4. 最终栈顶的结果就是最终想要的结果。

* [Leetcode-316-去除重复字母](https://leetcode-cn.com/problems/remove-duplicate-letters/)

  这个题有点难度，直接说核心思路：
  
  1. 用一个Map来记录每个字符最后在字符串中出现的下标，用一个Set来保存处理过的字符，保证一个字符只处理一次，用栈来保存结果。
  2. 遍历字符串中的每个字符，做如下操作
  3. 如果当前字符没有被处理过，那么判断当前字符是否小于栈顶字符且当前字符下标小于栈顶元素最后一次出现的下标。如果是，那么直接将栈顶元素出栈（因为它肯定不是最小的字典序）以及将栈顶字符标记为未处理。
  4. 将当前元素加入Set和栈中，继续3操作
  
* [Leetcode-394-字符串解码](https://leetcode-cn.com/problems/decode-string/)
  
  关键在于遇到]就需要解码"数字[字符串]"，将解码到的结果加入到栈中，核心思路如下：
  
  1. 首先遍历字符串中的每个字符，做如下操作：
  2. 如果不是]，那么直接入栈即可，否则进行下一步
  3. 如果是]，先求出[]中的字符串，再求出[]前面的数字，再将解码结果加入到栈中。
  4. 最后栈中的数据就是我们想要的结果
  
* [Leetcode-682-棒球比赛](https://leetcode-cn.com/problems/baseball-game/)
  
  这个题很简单，和150题逆波兰表达式求值差不多。
  
  

## 利用单调递增栈和单调递减栈

单调递增栈也就是栈底元素->栈顶元素的值是单调递增的。单调递减栈与之相反。

* [Leetcode-42-接雨水问题](https://leetcode-cn.com/problems/trapping-rain-water/)

  这个题的关键在于理解两个柱子之前能容纳的水取决于较短的那个柱子，所以这里我们可以利用单调递减栈来解决这个问题，核心思路如下：

  1. 遍历每个柱子，对每个柱子做下面的操作。
  2. 如果栈为空或者当前柱子高度小于栈顶柱子高度，那么直接入栈。
  3. 否则说明当前柱子高度大于栈顶柱子高度，那么将栈顶元素出栈，并计算当前柱子和栈顶柱子之前可以容纳水的数量（这里要注意出栈后栈为空就不用计算了）。然后继续第二步。
  
* [Leetcode-84-柱状图中的最大矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/)

  这个题和上面这个题类似。这个题用是维护一个单调递增栈，求以每个柱子的高度为高能形成的最大矩形，最终选出最大的矩形。这个题的核心在于要理解只有当下一个柱子高度小于当前柱子高度时，才能求以当前柱子高度为高所形成的最大矩形。因为如果下一个柱子高度大于当前柱子高度，那么说明以当前柱子高度为高形成的矩形面积一定还可以更大。用栈的解决思路如下：
  
  1. 遍历每个柱子，对每个柱子做接下来的操作
  2. 如果当前柱子高度小于栈顶柱子的高，以栈顶柱子的高度为高，当前柱子和栈顶柱子距离为宽，求矩形面积，并和最大矩形面积做比较更新。
  3. 否则将当前柱子入栈
  
  **注**：这里要注意特殊处理柱子高度是完全递增的情况。
  
* [Leetcode-85-最大矩形](https://leetcode-cn.com/problems/maximal-rectangle/)

  这个题其实就是84题的扩展题，看一张图（来源Leetcode题解区）就能明白这个题应该怎么做了。

  ![image-20201227161301845](https://fanshanchao.oss-cn-shenzhen.aliyuncs.com/img/image-20201227161301845.png)

  

* [Leetcode-173-二叉搜索树迭代器](https://leetcode-cn.com/problems/binary-search-tree-iterator/)

  这个题是让二叉搜索树迭代器的next()返回树中下一个最小的数。利用二叉搜索树的特性，我们可以维护一个单调递减栈，核心思路如下：

  1. 初始化节点时，按根左的递归顺序入栈。现在栈肯定是一个单调递减栈，且栈顶元素是二叉搜索树中最小元素。
  2. 调用next方法时，出栈栈顶元素，如果发现栈顶元素有右节点，那么需要重新调整这个单调递减栈，需要将右节点也按根左的递归顺序入栈。最后返回原来的那个栈顶元素即可。
  
* [Leetcode-402-移除掉K位数字](https://leetcode-cn.com/problems/remove-k-digits/)

  这个题的关键在于要理解前一位数字如果比当前数字要大，那么说明前一位数字必须要删除，其实想一下能很好理解，如果前一位比当前位数大不删除的话，后面的数字怎么删都不可能比删前一位数字小。我们可以用栈（其实用双端队列会更方便）来维护这个结果。核心思路如下：

  1. 遍历字符串中的每个字符，做如下操作：
  2. 如果当前字符数字小于前一个字符，那么将栈顶元素出栈，然后再将当前字符入栈

  **注：**这里要注意处理字符串是单调递增的情况

* [Leetcode-496-下一个更大的元素-1](https://leetcode-cn.com/problems/next-greater-element-i/)

  这个题其实就是维护一个原数据集的单调递减栈，在维护的过程中找出每个数组的下一个更大数字的下标。核心思路如下：

  1. 首先将第一个数字入栈，然后遍历数组，对数组每个元素做如下操作：
  2. 如果当前数字大于栈顶元素，那么说明找到了栈顶元素的笑一个更大数字，将栈顶元素出栈并记录下一个更大数字为当前数字，最后再将当前数字入栈。继续迭代处理。

* [Leetcode-503-下一个更大元素-2](https://leetcode-cn.com/problems/next-greater-element-ii/)

  这个题和496题类似，区别在于这是个循环数组，所以我们假设数组的长度为2*length。然后用496一样的方法操作即可。也就是进行两次的遍历数组。
  
* [Leetcode-739-每日温度](https://leetcode-cn.com/problems/daily-temperatures/)

  前面的这些题搞懂了这个题还是很简单的，其实就是维护一个单调递减栈，在维护的过程进行计算。核心思路如下：

  1. 遍历数组中的数字
  2. 如果当前元素小于栈顶元素则入栈。否则计算当前元素和栈顶元素的坐标差，这个坐标差就是栈顶元素需要等待的天数，继续迭代2。

## 二叉树的遍历

栈也非常适合用来进行栈的遍历，特别是层次遍历。一定要注意栈先进后出的这个特点，所以我们可以将需要先被遍历的节点入栈。

* [Leetcode-94-二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

  关键在于理解当前节点需要在它的左子树之前入栈，处理完左根节点，再处理右节点。利用栈的解决思路如下：

  1. 先将根节点入栈，此时当前节点为根节点
  2. 如果当前节点有左子树，然后将左子树入栈，循环执行2，直到当前节点没有左子树。
  3. 将栈顶元素出栈存入结果，判断是否有右子树，如果有则入栈，再跳转到2

* [Leetcode-144-二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)

  这个题和上面整个题类类似，只不过这里是最先处理根节点，核心思路如下：

  1. 最开始根节点为当前节点
  2. 处理当前节点，并判断当前节点是否有左节点，如果有则入栈，然后继续执行2
  3. 如果没有左节点，则将栈顶节点出栈，这里不做任何处理，因为之前栈顶元素已经做为当前节点被处理过了。继续4
  4. 如果栈顶元素有右子树，则将右子树标记为当前节点，继续2

* [Leetcode-145-二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

  其实后续遍历的结果刚好是前序遍历的**逆序**，所以按同样的方法求出前序遍历的结果，然后再逆序返回即可。
  
* [Leetcode-331-验证二叉树的前序序列化](https://leetcode-cn.com/problems/verify-preorder-serialization-of-a-binary-tree/)

  这个题首先要发现一个规律，如果是前序遍历，那么遍历到最后可以发现#的数量一定要比数字多一个，并且最后一个字符一定是#。用栈的思路如下：

  1. 遍历字符串中的每个字符
  2. 如果是数字则直接入栈
  3. 如果是#则出栈，并且判断出栈后栈是否为空，如果为空且字符串遍历到了最后一个直接返回true，否则返回false



## 其它

这些是栈的一些其它运用。

* [Leetcode-155-最小栈](https://leetcode-cn.com/problems/min-stack/)

    这个题就是维护一个能够在常数时间检索到栈内最小元素的栈。这个题的核心思路如下：

  1. 用一个变量来保存栈中最小元素。
  2. 入栈操作时判断当前元素是否小于栈中最小元素，如果是则将最小元素入栈（这里其实已经是倒数第二小的了），并且再将当前元素更新为最小元素并入栈。

  **注：**这里又将之前的最小元素入了一次栈，这是为了让出栈的时候如果出栈的元素刚好是最小元素，那么需要重新更新最小元素

  3. 出栈的时候判断如果栈顶是最小元素，那么连续出两次栈，并将最后一次出栈的结果更新为最小元素。

