# Oracle

> 本文笔记和总结大多数来自《收获，不止Oracle》这本书
>
> 本文基于Oracle19c

## 物理体系

​		Oracle是由**数据库**和**实例**组成的。数据库主要是存储数据的真正数据的地方，这里保存了数据库文件，日志文件之类的。Oracle的实例主要由缓存区和一堆线程构成。Oracle的物理体系图如下所示（图来自于《收获，不止Oracle》）：

![image-20210110150951069](https://fanshanchao.oss-cn-shenzhen.aliyuncs.com/img/image-20210110150951069.png)

​		简单说下这个图：

1. 实例部分由一个共享内存区域SGA和一系列后台线程组成。其中SGA主要被划分为共享池（shared pool）、数据缓存区（db cache）和日志缓存区（log buffer）三类。后台进程包括图2-2中所示的PMON、SMON、LCKn、RECO、CKPT、DBWR、LGWR、ARCH等系列进程。
2. 数据库部分由数据文件、参数文件、日志文件、控制文件、归档日志文件等一系列文件组成的，其中归档日志最终可能会被转移到新的存储介质中，用于备份恢复使用。

   ​	**先记住一点**，用户的请求经历的顺序是1区->2区->3区或者1区->2区（缓存命中的情况下），后面会详细说明每个区域的作用。这里重点先说一个区域：**PGA**。PGA也是一块内存区域，它和SGA最大的区别就是它是私有的。也就是说每个进程都会有个自己的PGA内存。PGA区域主要有以下三个作用：

3. 保存用户的连接信息。
4. 保存用户权限等信息。
5. 排序。如果相关进程的排序在PGA内有足够的内存进行，那么会在PGA中进行排序，否则会磁盘中进行排序。所以我们写排序语句的时候一定要注意这点，如果排序的数据特别大，可以考虑将PGA大小设置大一点。

### 一条简单查询SQL的执行顺序

结合上面的物理体系图，来看下一条简单的SQL的执行顺序是怎样的，以下面的SQL为例：

```sql
select user_name from t_student t where t.user_id = 1;
```

1. **进入1区（PGA区域）：**
   1. 该SQL语句首先会在1区作准备，也就是**保存用户的连接信息和权限的**。这里只要连接没有断开，下次就不用再去磁盘中读取相关数据，可以直接从PGA内存中获取。
   2. 为该SQL生成一条唯一的hash值。
2. **进入2区：**
   1. 进入SGA中的共享池区域，查询是否之前存过该SQL的hash值，如果有跳过解析，直接到下一步，如果没有，就要做如下的解析操作：
      * 首先检查语法是否正确，是否有权限
      * 存储该SQL的唯一hash值
      * 解析SQL。也就是判断这条SQL该怎样执行才是最高效的。
   2. 进入数据缓冲区，看数据缓存区中是否有我们需要的数据，如果有就直接返回数据，如果没有那么进入3区。
3. **进入3区：**
   1. 从数据库文件中获取数据并返回，我们都知道数据文件是在磁盘中的，所以速度是比较慢的。

### 一条简单的更新SQL执行顺序

拿下面这条SQL举例：

```sql
update t set t.object_id = 92 where t.object_id = 29;
```

1~3步和查询语句是一样的，但由于是更新语句，所以还要做一些额外的操作：

4. 数据在数据缓存区修改完数据后，会启用DBWR进程，完成更新的数据从内存中刷入磁盘，将磁盘中的object_id=29的值更新为92。



​		其实上面将数据写回磁盘这个操作，不是一定会立即被DBWR写进磁盘的。因为还有**日志缓冲区**，Oracle会对这个更新语句生成相应的日志信息，保存在日志缓冲区，这样就不用每次更新都将数据缓冲区的数据写回磁盘了。但是要注意，每次commit，日志缓冲区的日志是**会被写回磁盘的**。这样数据缓冲区就可以批量写回数据了，可以极大的提高性能。

​	关于日志缓存区的**大小配置**：如果日志缓冲区设置过大，那么批量刷出的量也比较大，Oracle性能会比较高，但是断电开机回复的时间也会比较长。反之亦然。

​	上面的物理体系图中，我们注意到DBWR进程左边还有一个线程CKPT线程，这个进程的作用是触发DBWR进行刷出数据。

### 后台进程

​		经过上面查询语句和更新语句的执行顺序，我们知道了SGA各个区域的作用，接下来再来看下Oracle中的进程们。下面并没有列出所有进程，主要是一些重要的进程。

1. **PMON：**进程监控器。如果你在执行某些更新语句，未提交时进程崩溃了，这时候PMON会自动回滚该操作，无须人工去执行ROLLBACK命令。除此之外它还可以干预后台进程，比如RECO出现异常失败了，此时PMON会重启RECO进程，如果遇到LGWR进程失败这样的严重问题，PMON会做出中止实例这个激烈的动作，用于防止数据错乱。
2. **SMON：**系统监控器。与PMON不同的是，SMON关注的是系统级的操作而非单个进程，工作重点在于实例恢复，除此之外还有清理临时表空间、清理回滚段表空间、合并空闲空间等功能。
3. **LCKn：**仅用于RAC数据库，用于实例间的封锁。
4. **RECO：**用于分布式数据库的恢复。适用场景也比较特俗。
5. CKPT：用于触发DBWR从数据缓存区中写出数据到磁盘。由Oracle的FAST_START_MTTR_TARGET参数控制。
6. **DBWR：**负责把数据从数据缓存区写到磁盘里，该进程和CKPT相辅相成，因为是CKPT促成DBWR去写的。不过DBWR也和LGWR密切相关，因为DBWR 想将数据缓存区中的数据写到磁盘的时候，必须通知 LGWR 先完成日志缓存区写到磁盘的动作后，方可开工。
7. **LGWR：**把日志缓冲区的数据从内存写入到磁盘的redo文件里。LGWR进程会在下面5个时机触发执行：
   1. 每隔三秒，LGWR运行一次。
   2. 任何COMMIT触发LGWR运行一次。
   3. DBWR要把数据从数据缓存写到磁盘，触发LGWR运行一次。
   4. 日志缓存区满三分之一或记录满1MB，触发LGWR运行一次。
   5. 联机日志文件切换也将触发LGWR。
8. **ARCH：**在LGWR写日志写到需要被覆盖重写的时候，触发ARCH进程去转移日志文件，将日志文件复制出去形成归档日志文件，以免日志丢失

### 回滚操作的执行顺序

​		还是拿上面那条更新语句来说，假设发生了回滚操作会按照执行下面的操作（不包括PGA和共享池区的经历，前面已经说过了）：

1. 将object_id=29数据从磁盘读取到缓冲区，当然如果缓冲区有就不用再读取了。
2. 在回滚表空间的相应回滚事务表上分配事务槽，从而在回滚表空间分配到空间。该动作需要记录日志写进日志缓存区。
3. 在数据缓存区中创建 object_id=29的前镜像，前镜像数据也会写进磁盘的数据文件里（回滚表空间的数据文件，我理解这就是undo日志，专门用于回滚），从缓存区写进磁盘的规律前面已经说过了，由CKPT决定，当然也别忘记这些动作都会记录日志，并将其写进日志缓存区，LGWR还在忙着将日志缓存区中的数据写入磁盘形成redo文件呢。
4. 将object_id=29修改为object_id=92，这个操作也要记录到日志缓存区的。
5. 此时用户如果执行了提交，日志缓存区立即要记录这个提交信息，然后就把回滚段事务标记为非激活INACTIVE状态，表示允许重写。
6. 6.如果是执行了回滚呢，Oracle需要从回滚段中将前镜像object_id=29的数据读出来，修改数据缓存区，完成回滚。这个过程依然要产生日志，要将数据写进日志缓存区。

这里涉及到一个回滚表空间的概念，把它理解为undo日志，undo日志用于回滚，而日志缓冲区的日志称为redo日志，用于记录操作。

### 一致性读

​		一致性读也就是查询的记录由查询的这一时间点决定，后面即便发生变化了，也要根据回滚段保存的前镜像记录，取到那个时间点的数据。所以Oracle的一致性读也可以用回滚段来实现。那么具体是怎么实现的呢？

​		先了解两个东西：

  1. **SCN：**这是一个只会增加不会减少的递增数字，存在于Oracle的最小单位块里，当某块改变时SCN就会递增。

  2. **回滚段记录事务槽：**如果你更新了某块，事务就被写进事务槽里。如果未提交或者回滚，该块就存在活动事务，数据库读到此块可以识别到这种情况的存在。

     假设我们8:00查询数据库，首先会获取8点那个时刻的SCN号，并记录下来。读取相关数据块是会判断当前数据库的SCN号是否小于8:00，如果小于说明可以读取，如果大于8:00会根据块中的事务槽中记录的相应undo地址，然后找到相应的undo块，将修改前的数据取出（SCN号大于8:00，说明数据在8:00后被修改过）。

     不过也要注意一点，不是当前SCN号大于等于当前块的SCN号就一定可以读，因为还可能有**活动事务**，所以Oracle还会判断是否有活动事务。活动事务就是在你查询开始时间之前都还未commit的事务。

### Oracle的启动和关闭

​		到这里估计可以发先上面物理体系图中还有参数文件和控制文件没有被提及过，这两个文件和数据的启动和关闭是息息相关的。数据库的启动可分为以下三个阶段：

1. **startup nomount阶段：**Oracle必须读取到数据库的参数文件（pfile或者spfile），如果读不到该参数文件，数据库根本无法nomount成功！如果读到参数文件，将完成一件非常重要的事，就是根据参数文件中的内存分配策略分配相应的内存区域，并启动相应的后台进程，换言之，就是创建实例instance。
2. **startup mount阶段：**实例已经创建了，Oracle继续根据参数文件中描述的控制文件的名称及位置，去查找控制文件，一旦查找到立即锁定该控制文件。控制文件里记录了数据库中的数据文件、日志文件、检查点信息等非常重要的信息，所以Oracle成功锁定控制文件，就为后续读取操作这些文件打下了基础，锁定控制文件成功就表示数据库mount成功，为实例和数据库之间桥梁的搭建打下了基础。
3. **alter database open阶段：**根据控制文件记录的信息，定位到数据库文件、日志文件等，从而正式打通了实例和数据库之间的桥梁。

### 一些小技巧

1. 共享池中缓存下来的SQL语句以及hash出来的唯一值，都可以在v$sql中对应的sql_text和sql_id字段中查询到，而解析的次数和执行的次数分别可以从PARSE_CALLS和EXECUTIONS字段中获取。

```sql
select t.SQL_TEXT,t.SQL_ID,t.PARSE_CALLS,t.EXECUTIONS
from v$sql t
where t.SQL_TEXT like '%sql语句%';
```

2. 预编译绑定变量能过减少Oracle解析sql的次数。
3. 存储过程中的execute immediate是一种动态SQL的写法，常用于表名和字段名是变量、入参的情况。在一些情况下可以考虑使用静态SQL写法、静态SQL在编译的时候就解析好了。
4. 要有批量提交的意识。
5. insert into t select ……的方式是将数据先写到DataBuffer中，然后再刷到磁盘中。而create table t 的方式却是跳过了数据缓存区，直接将数据写进磁盘，这种方式又称为直接路径读写方式，因为原本是数据先到内存，再到磁盘，更改为数据直接到磁盘，少了一个步骤，因而速度提升了许多。在进行海量数据插入的时候可以直接考虑适用create table t的方式。

## 逻辑体系

​		Oracle的逻辑结构从大到小分为：表空间（tablespace），段（segment），区（extent），块（extent）。先说下表空间这个概念，它是把一组数据文件捻在一起。一个数据库可以包含多个表空间，一个表空间只能属于一个数据库。一个表空间包含多个数据文件，一个数据文件只能属于一个表空间。

下面这个图（来自《收获，不止Oracle》）能够很清晰的看懂各个逻辑结构之前的关系：

![image-20210111222451512](https://fanshanchao.oss-cn-shenzhen.aliyuncs.com/img/image-20210111222451512.png)

​		数据库由若干表空间组成，表空间由若干个段组成，段由若干个区组成，区又是由Oracle的最小单元块组成的。其中表空间又包含系统表空间、回滚段表空间、临时表空间、用户表空间。这些表空间的作用后面会说到。

### Block

​		Block是Oracle最小的逻辑数据单位，Block默认大小为8kb。我们每次读取数据也是按块来读取的，所以就算你只查询一行记录，也至少会读取到一个块的数据。

​		再来说下Block的组成，Block被分为了5个部分：数据块头（包括标准内容和可变内容）（common and variable header）、表目录区（tabledirectory）、行目录区（row directory）、可用空间区（free space）、行数据区（row data）。下图（图来自《收获，不止Oracle》）是Block的结构图：

![image-20210111223719745](https://fanshanchao.oss-cn-shenzhen.aliyuncs.com/img/image-20210111223719745.png)

再来说下各个区域的作用：

1. **数据块头：**这个区域保存了数据库的概要信息，例如块地址及此数据块所属的段的类型（比如到底是表还是索引）。

2. **表目录区：**只要有一行数据插入到数据块中，那该行数据所在的表的信息将被存储在这个区域。

3. **行目录区：**存放插入行的地址。

4. **可用空间区：**就是块的空余空间，默认是10%，它的生效范围是段，所以可以为每个段配置不同的PCTFREE。这里涉及到一个问题，为什么要有空闲时间，把块填的满满的不好吗？

   > 答：可用空间区域可以减少不避免的行迁移，提高效率。例如我们对一条记录更新，数据库首先会尝试在保存它的数据快中寻找足够的空闲空间，如果没有足够的空闲空间，那么这条记录会被拆分为两个部分，也就是数据会被分布在多个块中，那么后续你查询的时候效率肯定会比较低下。还有一点，在只读数据库或者只有插入删除很少更新的数据库环境中，才适合将PCTFREE设置为0，因为这样读取一个块能读取到更多的数据。
   >
   > 关于行迁移的更多知识看这篇文章。[Oracle行迁移和行链接](https://blog.csdn.net/tomato__/article/details/40146573)

5. **行数据区：**存储的是具体的行的信息或者索引的信息，这部分占用了数据块绝大部分的空间。

Block的大小只有在建库的才可以指定，所以如果想改变块的大小，就必须在建库时指定。

### Extent

​		Extent就是把连续的Block组合到一起。**Extent是Oracle分配空间的最小单位**，**最小的逻辑单位是Block**。因为不可能每次申请空间都只申请一个Block，那样效率也太低了。Extent的大小我们也是可以配置的，默认大小是1MB。也就是说默认扩展大小是1MB。

​		Extent扩展的大小还可以由Oracle自行决定（也就是不使用固定扩展大小），在创建tablespace时用AUTOALLOCATE开启自动管理，但是这个自动管理的扩展大小也是有一个下限，那就是64kb。而固定大小用UNIFORM指令指定。

​		如下语句可以查看一个段中区的信息：

```sql
select * from user_extents where segment_name='T';
```



### Segment

​		当某用户创建一张表T时，实质就是建了一个数据段。只要段创建成功，数据库就一定为其分配了包含若干数据块的初始数据扩展（Extent）。但是这里要注意，一个表有可能不止一个段，例如分区表每个分区都是一个段。

​		我们可以在CREATE TABLE语句中使用STORAGE子句设定存储参数，决定创建表时为其数据段分配多少初始空间，或限定一个表最多可以包含多少数据扩展。如果用户没有为表设定存储参数，那么表在创建时使用所在表空间（tablespace）的默认存储参数

### TableSpace

​		一系列的Extend组成一个TableSpace。表空间又分为以下四种：

1. **系统表空间：**

2. **临时表空间：**可以被建多个，且可以被同时使用。临时表空间还可以为同一用户的不同SESSION设置不同临时表空间，也就是用临时表空间组。

   > 临时表空间组的推出，可以让我们往表空间组里不断新增临时表空间，让数据库在运行时自动从临时表空间组中选择各个临时表空间，不只是用户层面，而且是在 SESSION 层面进行IO均衡负载，极大地提升了数据库的性能

3. **回滚段表空间：**用于回滚数据还有实现一致性读。每个数据库使用的回滚段空间只能选择一个。那为什么要建多个回滚段呢？

   > 答：建多个回滚段的目的是可以瘦身，原先的回滚段一直扩展导致空间浪费太多，新建出来的小一点，切换成功后删除原来旧的回滚表空间，磁盘空间就空余出来了。

4. **数据表空间：**

```sql
--这个语句用来创建一个数据表空间，其它表空间创建语法可百度
create tablespace TBS_TEST01 datafile 'D:\Oracle19c\Test\Test01.DBF' size 100M extent management local segment space management auto;
```

​		在我们创建一个用户的时候，可以为它指定表空间，也可以使用默认的表空间。查看当前用户的默认表空间语句如下：

```sql
select username,default_tablespace from user_users;
```

​		下面语句可以查看一个表空间的使用情况：

```sql
select * from dba_data_files where tablespace_name = 'TBS_TEST01';
```

​		如果把表空间设置为不可自动扩展，那么在表空间空间不足时会报错。

### 一些小技巧

1. 如果某个表（或者说某段）中的记录增长得特别快，就可以考虑把这个区的大小设置得大一点，比如将initial extent和incremental extent都设置得比较大，这样申请扩展的次数就会减少，性能可以提高。

2. 可以根据数据库对表更新的频繁程度对表的PCTFREE做设置，免得产生行迁移，影响性能。PCTFREE就是块中的空闲区域。

3. 如果对行迁移进行优化？如何发现表存在大量的行迁移？

   > 1. 数据重建可以消除行迁移
   > 2. 执行如下命令：

   ```sql
   --1. 首先在命令行执行如下命令创建表chained_rows 这个utlchain.sql是oracle自带的，路径改成你的安装目录
    @ D:\Oracle19c\Oracle\rdbms\admin\utlchain.sql
   --2. 将产生了行迁移的数据放入chained_rows表中
   analyze table t list chained rows into chained_rows;
   select count(*) from chained_rows;
   ```

4. 对于数据仓库 OLAP 的数据库应用，我们一般倾向于将块设置得尽量大，而对于OLTP应用，块不要设置得太大。OLAP和OLTP的差别在于，前者一般查询返回大量的数据，而后者查询返回极少量数据。前者一般用户不多，并发不大，后者一般用户很多，并发很大。因此OLAP应用用得最多的查询方式应该是全表扫描，而OLTP应用用得最多的查询方式应该是索引读。

   > 实验中比较发现，在索引读返回少量记录这样的OLTP主打环境下，块的大小对性能影响不大。那为什么OLTP系统倾向于让块的尺寸小一些呢？主要是因为如果块太大，容易导致大量并发查询及更新操作都指向同一个数据块，从而产生热点块竞争。



## 表的特性

Oracle的表可以分为以下五种，每种表都有各自的优点和缺点。我们应该在实际业务场景中选择出最合适的表。

1. **普通堆表：**这种表就是我们平常使用的表。语法简单，能够适用大部分应用场景。但是也存在以下缺点：
   * 表更新日志开销较大
   * delete无法释放空间
   * 表记录太大检索较慢
   * 索引回表开销较大
   * 即使有序插入，也难以有序读出
2. **全局临时表：**这种表适用接口表设计，它能过高效删除，产生的日志也少，不同Session/事务可以独立使用一张表，且不会产生锁。但是这种表语法较为特别，且数据无法得到有效保护，毕竟是**临时**表。
3. **分区表：**这种表适合用于日志表。它能够有效的进行分区消除/清理/转移。但是语法比较复杂，一个表分区太多也会影响到效率。
4. **索引组织表：**这种表使用少更新的配置表。它的表就是索引，所以可以避免回表。但是也是语法复杂，且更新开销较大。
5. **聚簇表：**使用簇表关联查询的多表。优点是可以减少或避免排序，但是也是语法复杂，更新开销较大。

> 相关建表相关语句百度即可。

### 普通表

​		正常建表语句创建出来的表就是这里所说的普通表。这种表虽然适用于大多数业务场景但还是有一些缺点。下面将依次说明。

#### 表更新日志开销较大

​		对普通表做DML操作都会产生较多的日志，这些日志用于备份和恢复。虽然安全性得到了提高，但是效率也会随之下降。但在有些场景中，某些表的记录只是作为临时运算而根本不需要永久保留，这些表也不用写日志，这个时候用普通表就有些不适合了。可以用后面说到的临时表来处理这个场景。

​		这里再强调一次redo日志和undo日志。undo日志是用来记录需要回滚的数据，而redo日志用来记录操作，例如插入，更新，删除，提交事务这个操作。

#### delete无法释放空间

​		delete是很耗性能的操作。因为delete会产生大量的undo日志，而undo日志又需要redo来保护（记录这个操作）的缘故，delte产生的redo量也很大。并且delete 删除并不能释放空间，虽然delete将很多块的记录删除了，但是空块依然保留，Oracle在查询时依然会去查询这些空块，后续表有插入也会直接在这些空闲块中插入。而truncate是一种释放高水平位的动作，这些空块被回收，空间也被释放了。

​		虽然delete有很多缺点，但是在普通表中还是不可避免的要使用到它，那该如何提高性能？可以用后面说到的**分区表。**

​		**为什么delete比truncate慢？**

> ​		delete在删除数据是一行行删除的，日志也是一行行记录，而truncate是一次性删除，日志也是记录一次性的，所以性能要比delete要高。

#### 表记录太多检索太慢

​		虽然说表检索慢，我们可以使用索引来解决。但是在表记录太多的时候，因为索引还要进行回表，性能也不一定能高到哪去。如果表更新极少，可以选择用后面说到的**索引组织表。**

#### 有序插入却难有序读出

​		如果你把行记录插入块中，然后删除了该行，接下来插入的行会去填补块中的空余部分，这就无法保证有序了。要保证有序插入后还能有序读出，可以使用聚簇表。

### 全局临时表

​		全局临时表分为两种类型，一种是基于会话的全局临时表（on commit preserve rows），一种是基于事务的全局临时表（on commit delete rows）。上面说过全局临时表可以用来解决普通表更新日志开销大的这个问题。无论插入、更新还是删除，操作普通表产生的日志都比全局临时表要多。

​		全局临时表有以下两大特性：

		1. **高效删除记录：**全局临时表的记录会自动删除，产生的日志也很少。
  		2. **不同会话独立。**

​		一般来说，基于会话的全局临时表的应用会更多一些，少数比较复杂的应用，涉及一次调用中需要清空记录再插入等复杂动作时，才考虑用基于事务的全局临时表

### 分区表

​		分区表可以解决普通表记录太多检索慢和delete删除慢的这两个问题。因为对于分区表，检索数据可以只检索表中的一个或多个分区就可以了，而不用检索整个分区。分区表的某个分区还可以直接用truncate，所以分区表在一些场景下还能解决delete慢的问题。

#### 分区表的类型与原理

​		分区表可以分为以下四个类型：

1. **范围分区：**例如按时间列进行分区
2. **列表分区：**按某一列的值来进行分区。同一值的放到同一个分区。
3. **Hash分区：**Hash分区仅仅指定分区个数即可，Oracle会将Hash值在同一范围的数据放到一个分区。
4. **组合分区：**举个简单的例子，按范围-列表组合进行分区。

**为什么分区表和普通表有什么差异？**

1. 分区表会产生多个段，而且是建了几个分区就有几个段，而普通表仅有一个段。
2. 分区表可以指定不同的表空间，在不写明的情况下，都是指向默认表空间的。

> 分区表也是有额外开销的，如果分区数量过多，Oracle 就需要管理过多的段，在操作分区表时也容易引发Oracle内部大量的递归调用，此外，本身的语法也有一定的复杂度。所以一般来说，只有大表才建议建分区，记录数在100万以下的表，基本不建议建分区。

​		使用分区表可以享受到下面的特性：

1. 查询使用到分区条件可以极大的提升性能。
2. 可以对某一分区进行truncate操作。
3. 关于分区表的历史记录的处理，其实是可以分成删除和转移两部分的。
4. 分区表的分区不光可以切分，还可以**合并**。

#### 分区索引

​		前面说了分区表的很多优点，但是如果分区表的相关索引没有设计好，那么分区表的性能会比普通表还要差。分区表的索引分为**全局索引**和**普通索引**两种。全局索引就可以理解为普通索引，而分区索引是针对某个分区的索引。后面的索引部分再详细说下分区索引。

#### 使用分区表要注意的一些问题

1. 分区表的不当操作导致分区索引失效。这里的操作指的就是分区转移、切割、合并、增删，truncate分区等等。分区表的分区操作，对局部索引一般都没有影响，但是对全局索引影响比较大。Oracle在提供这些分区操作时提供了一个很有用的参数update global indexes，可以有效地避免全局索引失效。
2. 没有用到分区可能会导致索引效率低下。例如对id列建局部索引，查询时如果没有用到分区条件，会去检索每个分区的索引。从而导致索引效率低下。

### 索引组织表

​		索引表的表就是索引，索引就是表。所以访问索引组织表的数据无需进行回表操作。不过这种表的更新要比普通表的开销更大，因为表要和索引一样有序地排列，更新负担会很重。因此索引组织表适用在很少更新、频繁读取的应用场合，比如地区配置表，这种表中的数据一般很少变动，却有大量读取。

#### 簇表

​		有序簇表可以避免排序，但是簇表和索引组织表一样，由于结构的特殊性导致更新操作开销非常大，所以也需要谨慎使用。

## 索引

​		Oracle的索引有三种类型：BTREE索引，位图索引，函数索引。每种索引都有它适用的场景，我们要选择最适合的索引。我们可以对一个列建多个不同类型的索引，但在某一时刻只能用一个类型的索引。方法法就是先建一个在用的，再建其他类型的索引并用invisible关键字来声明，如果想用的时候就用visible来声明。

### BTREE索引

​		BTREE索引就是我们平常用到最多的索引，它底层的数据结构是**B+树**。Oracle底层的存储结构也是B+树，也就是说正常一张表的数据也是一个B+树，这颗B+树的检索条件（索引）是主键，并且叶子节点存储了所有的数据。而我们自己建的索引叶子节点存储的是rowid，所以一条使用了索引的查询语句要经历以下两个步骤：

1. 在索引B+树中找到符合条件的数据的rowid（一般是主键）。
2. 利用这个rowid再去主树中利用rowid检索到需要的数据，这一步也就是我们常说的回表。

下图是在索引的查询示意图（来自《收获，不止Oracle》）

![image-20210124164232887](https://fanshanchao.oss-cn-shenzhen.aliyuncs.com/img/image-20210124164232887.png)

> “Leaf（叶子块）主要存储key column value（索引列具体值）以及能具体定位到数据块所在位置的rowid（注意区分索引块和数据块）。

#### BTREE索引的特点

1. **索引高度较低：**这其实就是B+树的特点
2. **索引存储列值：**BTREE索引的叶子节点存储索引列的值和rowid。
3. **索引本身有序：**这也是B+树的特点。所以order by的列有索引能提高性能。

#### 分区索引

​		分区索引一定要利用好，用不好分区索引可能会出现很大的性能问题。如果设置了分区索引，但是却用不到分区条件，性能将继续下降。如果你建了分区索引，但是无法加上分区字段的条件，那建议不要建分区索引。

> 这里说的分区索引主要是指分区局部索引

#### 联合索引

​		使用联合索引时要注意以下几点：

1. 等值查询时，联合索引中的哪个列在前面效率都是一样的。
2. 如果是等值查询+范围查询，联合索引中等值查询的列在前，范围查询的列在后效率最高。

> 因为联合索引是先按第一个列排序，在第一个列相等时又按第二个列排序...自己列表格画个图出来即可理解上面这两个原理。

#### 索引的危害

​		任何事务都有两面性。索引虽然在很多情况下都能提高查询效率，但是索引却不是越多越好的，索引越多，那么在插入更新的时候还需要去维护多个索引，对插入更新的效率影响会很大，特别是无序插入的时候。我们在给表建索引的时候一定要谨慎！

​		索引的危害总结：

1. 对 insert 语句的负面影响最大，百害而无一利，只要有索引，插入就慢，索引越多越慢！

2. 对 delete 语句来说，有好有坏。在海量数据库中定位删除少数记录时，这个条件列是索引列显然是必要的，但是过多列有索引还是会有明显影响，因为其他列的索引也要因此被更新。在经常要删除大量记录的时候，危害加剧！

3. 对update语句的负面影响最小，快速定位少量记录并更新的场景和delete类似，但是具体修改某列时却有差别，不会触及其他索引列的维护。

   ​	建索引的过程会产生锁，而且不是行级锁，是把整个表锁住，任何该表的DML操作都将被阻止。

   ​	**那么我们该如何合理的控制索引的数量呢？**

   > 监控索引的使用情况，删除使用较少的索引。使用下面的语句即可监控索引访问情况。

   ```sql
   --监控索引
   alter index 索引名 monitoring usage;
   --观察监控结果
   select * from v$object_usage;
   ```

#### 优化小技巧

1. 如果查询返回绝大部分的数据，那用索引反而要慢得多。这个适合可以选择全表扫描。全表扫描一次可以读取多个块，不仅是一次读取一个块，这样IO的次数还可以大大降下来。
2. 给表某个列建立一个唯一索引可以极大的提高select count(**) from table的查询效率。虽然count(*)要全表扫描，但是索引块不用存储全部列，那么一个索引块可以存储更多的数据，在全表扫描时也不要扫描更多的块，减少了IO的次数，所以性能能得到提高。

> SUM/AVG函数的优化方案和count(*)类似。

3. 对MAX和MIN的优化则使用非唯一索引即可。但是要注意一点，如果同时查MAX和MIN那么会导致索引失效。例如下面的语句：

```sql
select MAX(object_id),MIN(object_id) from t;
--可以使用下面的语句进行优化
select max,min
from (select MAX(object_id) max from t)a,(select MIN(object_id) min from t) b;
```

4. 一定要确认好一条查询语句需要查询的列，查询过多的列可能会导致回表查询/全表扫描。

5. 可以考虑使用联合索引来避免回表操作。但联合索引不宜多于3个字段。

6. 聚合因为决定了回表查询的速度。这里的聚合因子指的是表和索引两者的排序顺序相似度。相似度很高，我们就称之为聚合因子比较低。

   > 记住一点：表的插入顺序和索引列的顺序基本一致，从索引中回表查找数据块将会更容易就可以了

7. order by的列尽量保证有索引，特别是大表。因为索引本身就是有序的，可以避免排序。

8. distinct操作会对数据进行排序，索引可以提高一点效率，但是不是很明显。一般用到distinct的时候我们都必须先思考表为什么会有重复记录？

9. 执行计划的INDEX FASTFULL SCAN会比INDEX FULL SCAN更快，那是因为索引快速全扫描一次读取多个索引块，而索引全扫描一次只读取一个块。一次读取多个块不容易保证有序，而一次读取一个块可以保证有序，因此在有排序的场合，INDEX FULL SCAN的顺序读可以让排序消除，INDEXFAST FULL SCAN虽然减少了逻辑读，但是排序这个动作却无法消除。

10. union操作会进行排序，所以效率比union all要慢。

11. 如果单列的查询列和联合索引的前置列一样，那单列可以不建索引，直接利用联合索引来进行检索数据。

### 位图索引

​		什么是位图索引？下面两张图（图来自《收获，不止Oracle》）即可搞清楚什么是位图索引。

![image-20210124181647569](https://fanshanchao.oss-cn-shenzhen.aliyuncs.com/img/image-20210124181647569.png)

![image-20210124181905376](https://fanshanchao.oss-cn-shenzhen.aliyuncs.com/img/image-20210124181905376.png)

上面第一张图是一张表，第二张图是在这个表的sex列建立了位图索引后。这里的0和1就是个比特位占用空间特别小。所以在有位图索引的情况下，使用count(*)效率非常的高。位图索引在列的重复度很低时，占用的体积非常小。

​		但是位图索引还是有一些限制的，位图索引使用要满足下面两个条件：

1. 位图索引列大量重复
2. 该表极少更新。因为位图索引中的一个值涉及到很多的数据，更新时很容易锁到很多数据。

### 函数索引

​		对列做运算可能会导致BTREE索引失效，如果一定需要用到索引，这个时候可以选择用函数索引。函数索引就是因为在很多情况下，SQL语句的写法是对列进行运算，而普通的索引没法适用于此类SQL语句，所以不得不建一种特殊的索引，这种特殊索引就是函数索引。

​		一般来说函数索引很少用到，在用函数索引之前都要仔细地确认下，是否可以避免对列进行行运算，从而使这个列能够用到正常BTREE索引。

## 表的连接

​		Oracle的表连接也分有三种类型：嵌套循环，散列连接，排序合并。这三种连接都有各自的优缺点，Oracle会选择最适合的连接方式进行表的连接。

​		我们先按下面的步骤，构造出两张测试表t1和t2：

```sql
create table t1(id number not null,n number,contents varchar2(4000));
create table t2(id number not null,n number,contents varchar2(4000));

--需要在命令行页面执行
execute dbms_random.seed(0);

-- 往t1表中插入顺序混乱的100条数据
insert into t1 
select rownum,rownum,dbms_random.string('a',50)
from dual
connect by level <= 100
order by dbms_random.random;

-- 往t2表中插入顺序混乱的100000条数据
insert into t2 
select rownum,rownum,dbms_random.string('a',50)
from dual
connect by level <= 100000
order by dbms_random.random;
```



### 嵌套连接

​		嵌套连接就是我们用的最多的表连接方式，也就是使用笛卡尔积的方式进行表连接。例如A表和B表进行连接，A表中的第一条数据会和B中的所有数据依次进行匹配，匹配成功后再处理A表中的第二条，也是同样的操作.....	

​		最适合用嵌套连接的场景如下：

1. 两表关联返回的记录不多，最佳情况是驱动表结果集仅返回1条或少量几条记录，而被驱动表仅匹配到1条或少量几条记录，这种情况即便t1表和t2表的记录奇大无比，速度也是非常快的。
2. 遇到一些不等值查询导致散列连接和排序合并连接被限制使用，不得不使用嵌套循环连接。
3. 驱动表的限制条件所在的列有索引。
4. 被驱动表的连接条件所在的列有索引。

### 排序合并连接

​		排序合并连接就和它的名字一样，连接的两个表必须是按连接条件进行过排序的表。这样在匹配的过程中就能节省大量的时间。

### 散列连接

​		散列连接其实就是先用驱动表来建立一个哈希列表，再去被驱动表中利用哈希函数找到匹配的数据。因为要建立哈希列表，所以散列连接需要消耗额外的内存建立哈希列表。

​		两表关联等值查询，在没有任何索引的情况下，Oracle倾向于走散列连接这种算法，因为散列连接的算法本身是比较高效且先进的。散列连接需要在 PGA 中的 HASH_AREA_SIZE中完成，因此增大HASH_ARAE_SIZE也是优化散列连接的一种有效途径，一般在内存自动管理的情况下，我们只要加大PGA区的大小即可。

### 三种连接的对比

#### 表的访问次数对比

如何看一条SQL中表的访问次数可以看[这篇博客](https://blog.csdn.net/sinat_28472983/article/details/82382239)：

* **嵌套连接：**在嵌套循环连接中，驱动表返回多少条记录，被驱动表就被访问多少次。执行计划中的Starts是表被访问的次数（这个字段信息必须在命令行页面看，必须等SQL执行完才能看到）。
* 在散列连接中，驱动表和被驱动表都只会被访问0次或者1次。在散列连接中，驱动表和被驱动表都只会被访问0次或者1次。
* **排序合并连接：**排序合并连接根本就没有驱动和被驱动的概念，而嵌套循环连接和散列连接要考虑驱动和被驱动情况。而对于排序合并连接中的表的访问次数也是0次或者1次。

#### 表驱动顺序的影响

* **嵌套连接：**嵌套循环连接要特别注意驱动表的顺序，先访问小的结果集，后访问大的结果集，才能保证被驱动表的被访问次数降到最低，从而提升性能。
* **散列连接：**散列连接和嵌套连接也一样，小表在前，大表在后。
* **排序合并连接：**嵌套循环连接和散列连接有驱动顺序，驱动表的顺序不同将影响表连接的性能，而排序合并连接没有驱动的概念，无论哪张表在前都无妨。

#### 各类连接限制场景对比

* **散列连接：**由于使用的是哈希函数来匹配数据，所以散列连接不支持不等值连接<>，不支持>和<的连接方式，也不支持LIKE的连接方式。
* **排序合并连接：**排序合并连接不支持<>连接条件，也不支持 LIKE 连接条件，但是比起散列连接，它的支持面要广一些，支持>之类的连接条件。这样想一下也能明白，如果用<>条件进行连接，那么被驱动表中大部分数据都会被匹配上，那么岂不是和嵌套连接一样，还多了个排序操作，性能肯定会受到影响，所以不支持<>，like。
* **嵌套连接：**笛卡尔积永远的神，肯定是能支持所有场景的。

#### 索引对几种连接的影响

​		索引对于嵌套循环连接来说非常重要，既要考虑驱动表的限制条件上的索引，又要考虑被驱动表的连接条件上的索引；而索引对于散列连接来说，仅需考虑限制条件上的索引是否能用上索引，连接条件上的索引是不能发挥作用的；排序合并连接和散列连接又有差别，排序合并连接上的连接条件虽 然没有检索的作用，却有消除排序的作用。



## 优化技巧

1. distinct去重可以通过中间新增一个中间表来解决。
2. 学会使用批量commit。



